// Service de tickets avec Supabase
// PostgreSQL serverless avec API REST automatique

import QRCode from 'qrcode';
import { supabaseDatabase, TicketData } from './database-supabase';
import { OrderData } from '../src/email-templates';

export interface TicketGenerationOptions {
  orderId: number;
  orderNumber: number;
  customerEmail: string;
  lineItems: any[];
  currency: string;
  size?: number;
  margin?: number;
  color?: {
    dark?: string;
    light?: string;
  };
}

export class TicketServiceSupabase {
  private baseUrl: string;

  constructor() {
    this.baseUrl = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
  }

  // G√©n√©rer des tickets pour une commande
  async generateTicketsForOrder(options: TicketGenerationOptions): Promise<TicketData[]> {
    const { orderId, orderNumber, customerEmail, lineItems, currency, size = 200, margin = 2, color = {} } = options;
    
    const tickets: TicketData[] = [];

    for (const item of lineItems) {
      // Ignorer les frais de service
      if (item.title.toLowerCase().includes('service') || 
          item.title.toLowerCase().includes('frais') ||
          item.title.toLowerCase().includes('charge')) {
        continue;
      }

      // Cr√©er un ticket pour chaque quantit√©
      for (let i = 0; i < item.quantity; i++) {
        const ticketId = this.generateTicketId(orderNumber, item.title, i + 1);
        const ticketTitle = this.cleanTicketTitle(item.title);
        
        // G√©n√©rer l'URL de validation
        const validationUrl = `${this.baseUrl}/api/ticket/validate/${ticketId}`;
        
        // G√©n√©rer le QR code
        const qrCodeDataURL = await QRCode.toDataURL(validationUrl, {
          width: size,
          margin: margin,
          color: {
            dark: color.dark || '#8B4513',
            light: color.light || '#FDF8ED'
          },
          errorCorrectionLevel: 'M'
        });

        const ticket: TicketData = {
          id: this.generateId(),
          orderId,
          orderNumber,
          ticketId,
          customerEmail,
          ticketTitle,
          quantity: 1,
          price: item.price,
          currency,
          qrCodeData: qrCodeDataURL,
          status: 'pending',
          createdAt: new Date().toISOString()
        };

        // Sauvegarder en base Supabase
        const saved = await supabaseDatabase.createTicket(ticket);
        if (saved) {
          tickets.push(ticket);
          console.log(`üé´ Ticket g√©n√©r√©: ${ticketId}`);
        }
      }
    }

    console.log(`‚úÖ ${tickets.length} tickets g√©n√©r√©s pour la commande #${orderNumber}`);
    return tickets;
  }

  // Valider un ticket
  async validateTicket(ticketId: string, validatedBy: string, notes?: string): Promise<boolean> {
    const ticket = await supabaseDatabase.getTicketByTicketId(ticketId);
    
    if (!ticket) {
      console.error(`Ticket non trouv√©: ${ticketId}`);
      return false;
    }

    if (ticket.status !== 'pending') {
      console.error(`Ticket d√©j√† trait√©: ${ticketId}`);
      return false;
    }

    const success = await supabaseDatabase.updateTicketStatus(ticketId, 'validated', validatedBy, notes);
    
    if (success) {
      console.log(`‚úÖ Ticket valid√©: ${ticketId} par ${validatedBy}`);
    }
    
    return success;
  }

  // Marquer un ticket comme utilis√©
  async markTicketAsUsed(ticketId: string): Promise<boolean> {
    const ticket = await supabaseDatabase.getTicketByTicketId(ticketId);
    
    if (!ticket) {
      console.error(`Ticket non trouv√©: ${ticketId}`);
      return false;
    }

    // V√©rifier si le ticket est d√©j√† utilis√©
    if (ticket.status === 'used') {
      console.log(`Ticket d√©j√† utilis√©: ${ticketId}`);
      return true; // Consid√©rer comme succ√®s si d√©j√† utilis√©
    }

    const success = await supabaseDatabase.updateTicketStatus(ticketId, 'used');
    
    if (success) {
      console.log(`üé´ Ticket marqu√© comme utilis√©: ${ticketId}`);
    }
    
    return success;
  }

  // Obtenir les informations d'un ticket
  async getTicketInfo(ticketId: string): Promise<TicketData | null> {
    return await supabaseDatabase.getTicketByTicketId(ticketId);
  }

  // Obtenir tous les tickets
  async getAllTickets(): Promise<TicketData[]> {
    return await supabaseDatabase.getAllTickets();
  }

  // Obtenir les statistiques
  async getStats() {
    return await supabaseDatabase.getStats();
  }

  // Recherche de tickets
  async searchTickets(filters: {
    status?: string;
    orderNumber?: number;
    customerEmail?: string;
    dateFrom?: string;
    dateTo?: string;
  }): Promise<TicketData[]> {
    return await supabaseDatabase.searchTickets(filters);
  }

  // G√©n√©rer un ID de ticket unique
  private generateTicketId(orderNumber: number, title: string, index: number): string {
    const cleanTitle = this.cleanTicketTitle(title).toLowerCase().replace(/[^a-z0-9]/g, '');
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 4);
    
    return `${orderNumber}_${cleanTitle}_${index}_${timestamp}_${random}`;
  }

  // Nettoyer le titre du ticket
  private cleanTicketTitle(title: string): string {
    return title
      .replace(/üé´/g, '')
      .replace(/MR NJP Event's/g, 'MR NJP Events')
      .replace(/\s+/g, ' ')
      .trim();
  }

  // G√©n√©rer un UUID v4
  private generateId(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
}

export const ticketServiceSupabase = new TicketServiceSupabase();
